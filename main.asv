%% main.m – Experimentos Friedkin–Johnsen 
%===========================================================================
% Generación de redes ER, simulación Friedkin–Johnsen,
% métricas espectrales, conectividad, primitividad,
% centralidad, convergencia, figuras y tablas.
%===========================================================================

%% 0 · LIMPIEZA
clear; close all; clc;

%% 1 · PARÁMETROS BASE
param.rango_opiniones  = [-0.7, 0.7];
param.seed_base        = 123;
param.iteraciones      = 1000;
param.tol_consenso     = 0.05;
param.tol_polarizacion = 0.60;

%% 2 · DEFINIR ESCENARIOS
sizes    = [20, 50, 100];
propNegVals = [0.0, 0.15, 0.3];  % proporción de trolls negativos
propPosVals = [0.0, 0.15, 0.3];  % proporción de trolls positivos
pVals    = [0.1, 0.3, 0.7];
simFlags = [true, false];

c = 1;
for n = sizes
  for propNeg = propNegVals
    for propPos = propPosVals
      neg = round(propNeg * n);
      pos = round(propPos * n);
      if neg + pos >= n, continue; end
      for p = pVals
        for sim = simFlags
          esc(c) = struct( ...
            'n',    n, ...
            'neg',  neg, ...
            'pos',  pos, ...
            'p',    p, ...
            'sim',  sim, ...
            'seed', param.seed_base + c, ...
            'tag',  sprintf('n%d_neg%d_pos%d_p%.2f_%s', ...
                       n, neg, pos, p, tern(sim,'sim','dir')) ...
          );
          c = c + 1;
        end
      end
    end
  end
end

%% 3 · PREPARAR RESULTADOS
resultsRoot = 'C:/Users/HP/Documents/4 mates/TFG/modelomatlab';
tsStr       = datestr(now,'yyyy-mm-dd_HHMMSS');
resultsDir  = fullfile(resultsRoot, ['resultados_' tsStr]);
if ~exist(resultsDir,'dir'), mkdir(resultsDir); end
diary(fullfile(resultsDir,'log.txt'));

% Inicializar struct array
M = struct( ...
  'tag',{}, 'n',{}, 'neg',{}, 'pos',{}, 'p',{}, 'sim',{}, ...
  'irreducible',{}, 'periodo',{}, 'primitiva',{}, ...
  'rho_emp',{}, 'rho_teor',{}, 'norma2',{}, ...
  'rangoFinal',{}, 'stdFinal',{}, 'polarizado',{}, ...
  'avgCentTrolls',{}, 'avgCentNormals',{}, 'convTime',{}, ...
  'total_trolls',{}, 'prop_trolls_pos',{} ...
);
cnt = 1;

%% 4 · BUCLE PRINCIPAL
for i = 1:numel(esc)
  s = esc(i);
  rng(s.seed,'twister');

  % 4.1 · Generar ER simple
  A = rand(s.n) < s.p;
  if s.sim
    A = A | A.';  % no dirigido
  end

  % 4.2 · Normalizar filas → W
  W = A ./ max(sum(A,2),1);

  % 4.3 · Comprobar simetría
  A_test = double((W~=0) | (W.'~=0));
  if s.sim && ~issymmetric(A_test)
    warning('Adjacency no simétrica en %s', s.tag);
  end

  % 4.4 · Irreducibilidad
  if s.sim
    irr = (max(conncomp(graph(A_test))) == 1);
  else
    irr = (max(conncomp(digraph(A),'Type','strong')) == 1);
  end

  % 4.5 · Periodicidad y Primitividad
  if ~s.sim && irr
    d    = calcularPeriodoGrafo(A_test);
    prim = (d == 1);
  else
    d    = NaN;
    prim = irr;  % irreducible no dirigido → primitivo
  end

  % 4.6 · Radio espectral y norma 
  ev      = eig(W);
  rho_emp = max(abs(ev));
  norma2  = norm(W);

  % 4.7 · Rho teórico (ER)
  rho_teor = s.p * (s.n - 1);

  % 4.8 · Opiniones iniciales
  x0    = zeros(s.n,1);
  ids   = randperm(s.n);
  trolls_neg = ids(1:s.neg);
  trolls_pos = ids(s.neg+1:s.neg+s.pos);
  normales   = setdiff(1:s.n,[trolls_neg,trolls_pos]);
  trolls     = [trolls_neg, trolls_pos];
  x0(trolls_neg) = -1;
  x0(trolls_pos) = 1;
  x0(normales)   = param.rango_opiniones(1) + ...
    diff(param.rango_opiniones) * rand(numel(normales),1);

  % 4.9 · Simulación Friedkin–Johnsen
  lambdas = zeros(s.n,1);
  lambdas(normales) = 0.5 + 0.3*rand(numel(normales),1);
  X = simularFriedkin(W, x0, lambdas, param.iteraciones);

  % 4.10 · Métricas de polarización
  rf  = max(X(:,end)) - min(X(:,end));
  sd  = std(X(:,end));
  pol = (rf > 0.8) && (sd > 0.3);

  fig = figure('Visible','off');
  visualizarEvolucionFriedkin(X, trolls_neg, trolls_pos, normales, param.rango_opiniones);
  guardarFigura(fig, resultsDir, ['evol_' safeName(s.tag) '.png']);

  % 4.12 · Convergencia 
  cm = analizarConvergenciaFriedkin(W, lambdas);
  fprintf('π^T x0 ponderado = %.3f\n', cm.pi' * x0);

  % 4.13 · Eigenvector centrality manual (left PF-vector de W)
  [V,D]   = eig(W.');
  [~, idx]= max(abs(diag(D)));
  pi_vec  = real(V(:,idx));
  pi_vec  = abs(pi_vec) / sum(abs(pi_vec));

  avgCentT = mean(pi_vec(trolls));    
  avgCentN = mean(pi_vec(normales));  

  % 4.14 · Tiempo de convergencia
  rango_it = max(X,[],1) - min(X,[],1);
  tconv    = find(rango_it < param.tol_consenso,1);
  if isempty(tconv), tconv = NaN; end

  % 4.15 · Guardar datos individuales
  save(fullfile(resultsDir,[safeName(s.tag) '.mat']), 'W','x0','lambdas','X');

  % 4.16 · Variables adicionales
  total_trolls = s.neg + s.pos;
  prop_pos = s.pos / (total_trolls + eps);

  % 4.17 · Almacenar en struct
  M(cnt) = struct( ...
    'tag',           s.tag,    ...
    'n',             s.n,      ...
    'neg',           s.neg,    ...
    'pos',           s.pos,    ...
    'p',             s.p,      ...
    'sim',           s.sim,    ...
    'irreducible',   irr,      ...
    'periodo',       d,        ...
    'primitiva',     prim,     ...
    'rho_emp',       rho_emp,  ...
    'rho_teor',      rho_teor, ...
    'norma2',        norma2,   ...
    'rangoFinal',    rf,       ...
    'stdFinal',      sd,       ...
    'polarizado',    pol,      ...
    'avgCentTrolls', avgCentT, ...
    'avgCentNormals',avgCentN, ...
    'convTime',      tconv,    ...
    'total_trolls',  total_trolls, ...
    'prop_trolls_pos', prop_pos ...
  );
  cnt = cnt + 1;
end

%% 5 · EXPORTAR TABLA Y CSV
T = struct2table(M);      % crear tabla en workspace
writetable(T, fullfile(resultsDir,'summary_metrics.csv'));
save(fullfile(resultsDir,'summary_metrics.mat'),'T');
disp(T);

analisis(resultsDir);
